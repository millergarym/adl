// This is based on Golang's modules and workspace.
// e.g. see https://go.dev/ref/mod#workspaces

module adlc.packaging {

import sys.types.Pair;
import sys.adlast2.ScopedName;
import sys.adlast2.Module1;

// AdlWorkspace0 is the serilization format
type AdlWorkspace0 = AdlWorkspace<AdlPackageRef>;
type AdlWorkspace1 = AdlWorkspace<Payload1>;
type AdlWorkspace2 = AdlWorkspace<Payload2>;

struct Payload1 {
    AdlPackageRef p_ref;
    AdlPackage pkg;
};

struct Payload2 {
    AdlPackageRef p_ref;
    AdlPackage pkg;
    Vector<Module1> modules;
};

/// Expected to live in a file named `adl.work.json`
struct AdlWorkspace<T> {
    String adlc;
    Vector<T> use;
    Vector<RuntimeOpts> runtimes = [];
    Bool use_embedded_sys_loader = true;
};

union RuntimeOpts {
    TsWriteRuntime ts_runtime;
};

struct TsWriteRuntime {
    String outputDir;
    ReferenceableScopeOption referenceable = "local";
    String npm_pkg_name = "@adl-lang/runtime";
    TsStyle ts_style = "tsc";
};

// key must be a path to a directory directly under the folder containing the `adl.work.json` file.
// type AdlPackageRefs = StringMap<AdlPackageRef>;

type AdlPackageRefs = Vector<AdlPackageRef>;

struct AdlPackageRef {
    String path;
    Nullable<TypescriptGenOptions> ts_opts = null; 
};

struct TypescriptGenOptions {
    String npm_pkg_name;
    String npm_version = "1.0.0";
    StringMap<VersionSpec> extraDependencies = {};
    StringMap<VersionSpec> extraDevDependencies = {};
    Nullable<OutputOpts> outputs = null;
    TsRuntimeOpt runtime_opts = { "packageRef": {"name": "@adl-lang/runtime", "version": "^1.0.0"} };
    Bool generate_transitive = false;
    Bool include_resolver = false;
    TsStyle ts_style = "tsc";
    ModuleSrc modules = "all";
    Bool capitalize_branch_names_in_types = true;
    Bool capitalize_type_names = true;

    Vector<InjectAnnotation> annotate = [];
// Vector<> searchDir;
// --merge-adlext=EXT
// --verbose
// --no-overwrite
// --exclude-ast
// --excluded-ast-annotations=SCOPEDNAMES
};

union InjectAnnotation {
    Pair<ScopedName,Json> module_;
};

union TsRuntimeOpt {
    String workspaceRef;
    NpmPackageRef packageRef;
    TsGenRuntime generate;
};

struct TsGenRuntime {
    // this is currently hardcoded to "./runtime"
    // String runtimeDir;
};

union OutputOpts {
    GenOutput gen;
    // PkgRef ref;
};

// struct PkgRef {
// };

struct GenOutput {
    ReferenceableScopeOption referenceable = "local";
    String outputDir;
    Nullable<String> manifest = null;
};

union TsStyle {
    Void tsc;
    Void deno;
};

union ModuleSrc {
    Void all;
    Vector<String> modules;
};

union ReferenceableScopeOption {
    /// Generated code will only be referred internal to the repo
    Void local;
    /// Generated code can be published via a package manager (e.g. npm)
    Void remote;
};

/// Expected to live in a file named `adl.pkg.json`
struct AdlPackage {
    String path;
    Nullable<String> globalAlias = null;
    /// Version
    String adlc;
    Vector<Require> requires = [];
    Vector<Exclude> excludes = [];
    Vector<Replace> replaces = [];
    Vector<Retract> retracts = [];
};

struct PackageDirective {
    String path;
    Nullable<String> repo = null;
};

struct Require {
    PkgRef ref;
    Nullable<String> version = null;
    Bool indirect = false;
};

union PkgRef {
    String path;
    String alias;
};

struct Exclude {
    String path;
    String version;
};

struct Replace {
    String path;
    Nullable<String> version;
};

struct Retract {
    String version;
    Nullable<String> comment = null;
};

struct NpmPackage {
    String name;
    String version;
    StringMap<String> scripts = {};
    StringMap<String> dependencies = {};
    StringMap<String> devDependencies = {};
};

// union DependencySpec {
//     Void workspace;
//     VersionSpec semverSpec;
// };

struct NpmPackageRef {
    String name;
    VersionSpec version;
};

type VersionSpec = String;

};
