// This is based on Golang's modules and workspace.
// e.g. see https://go.dev/ref/mod#workspaces

module adlc.packaging {

import sys.types.Pair;
import sys.adlast2.ScopedName;
import sys.adlast2.Module1;

// AdlWorkspace0 is the serilization format
type AdlWorkspace0 = AdlWorkspace<AdlPackageRef>;
type AdlWorkspace1 = AdlWorkspace<Payload1>;
type AdlWorkspace2 = AdlWorkspace<Payload2>;

struct Payload1 {
    AdlPackageRef p_ref;
    AdlPackage pkg;
};

struct Payload2 {
    AdlPackageRef p_ref;
    AdlPackage pkg;
    Vector<Module1> modules;
};

/// Expected to live in a file named `adl.work.json`
struct AdlWorkspace<T> {
    String adlc;
    Vector<T> use;
    Vector<RuntimeOpts> runtimes = [];
    Nullable<Payload1> embedded_sys_loader = {
        "p_ref": {
            "path": "",
            "ts_opts": {
                "npm_pkg_name": "@adl-lang/sys",
                "npm_version": "1.0.0",
                "extra_dependencies": {
                    "base64-js": "^1.5.1"
                },
                "extra_dev_dependencies": {
                    "tsconfig": "workspace:*",
                    "typescript": "^4.9.3"
                }
            }
        },
        "pkg": {
            "path": "github.com/adl-lang/adl/adl/stdlib/sys",
            "global_alias": "sys",
            "adlc": "0.0.0"
        }
    };
};

// struct EmbeddedSysLoaderOpt {
//     AdlPackageRef p_ref;
//     AdlPackage pkg;
//     // String npm_pkg_name;
//     // String npm_version = "1.0.0";
//     // TsStyle ts_style = "tsc";
//     // StringMap<String> dependencies = {};
//     // StringMap<String> devDependencies = {};
// };

union RuntimeOpts {
    TsWriteRuntime ts_runtime;
};

struct TsWriteRuntime {
    String output_dir;
    ReferenceableScopeOption referenceable = "local";
    String npm_pkg_name = "@adl-lang/runtime";
    TsStyle ts_style = "tsc";
    Bool strip_first = true;
};

// key must be a path to a directory directly under the folder containing the `adl.work.json` file.
// type AdlPackageRefs = StringMap<AdlPackageRef>;

type AdlPackageRefs = Vector<AdlPackageRef>;

struct AdlPackageRef {
    String path;
    Nullable<TypescriptGenOptions> ts_opts = null; 
};

struct TypescriptGenOptions {
    String npm_pkg_name;
    String npm_version = "1.0.0";
    StringMap<VersionSpec> extra_dependencies = {};
    StringMap<VersionSpec> extra_dev_dependencies = {};
    Nullable<OutputOpts> outputs = null;
    TsRuntimeOpt runtime_opts = { "package_ref": {"name": "@adl-lang/runtime", "version": "^1.0.0"} };
    Bool generate_transitive = false;
    Bool include_resolver = false;
    TsStyle ts_style = "tsc";
    ModuleSrc modules = "all";
    Bool capitalize_branch_names_in_types = true;
    Bool capitalize_type_names = true;

    Vector<InjectAnnotation> annotate = [];
// Vector<> searchDir;
// --merge-adlext=EXT
// --verbose
// --no-overwrite
// --exclude-ast
// --excluded-ast-annotations=SCOPEDNAMES
};

union InjectAnnotation {
    Pair<ScopedName,Json> module_;
};

union TsRuntimeOpt {
    String workspace_ref;
    NpmPackageRef package_ref;
    TsGenRuntime generate;
};

struct TsGenRuntime {
    // this is currently hardcoded to "./runtime"
    // String runtimeDir;
};

union OutputOpts {
    GenOutput gen;
    // PkgRef ref;
};

// struct PkgRef {
// };

struct GenOutput {
    ReferenceableScopeOption referenceable = "local";
    String output_dir;
    Nullable<String> manifest = null;
    /// When creating the path for output ts files delete the first part of the module name
    /// This needs to be false for "generate_transitive" and 
    /// packages like "common" where the module and directory at the top level named the same.
    Bool strip_first = true;
};

union TsStyle {
    Void tsc;
    Void deno;
};

union ModuleSrc {
    Void all;
    Vector<String> modules;
};

union ReferenceableScopeOption {
    /// Generated code will only be referred internal to the repo
    Void local;
    /// Generated code can be published via a package manager (e.g. npm)
    Void remote;
};

/// Expected to live in a file named `adl.pkg.json`
struct AdlPackage {
    String path;
    Nullable<String> global_alias = null;
    /// Version
    String adlc;
    Vector<Require> requires = [];
    Vector<Exclude> excludes = [];
    Vector<Replace> replaces = [];
    Vector<Retract> retracts = [];
};

struct PackageDirective {
    String path;
    Nullable<String> repo = null;
};

struct Require {
    PkgRef ref;
    Nullable<String> version = null;
    Bool indirect = false;
};

union PkgRef {
    String path;
    String alias;
};

struct Exclude {
    String path;
    String version;
};

struct Replace {
    String path;
    Nullable<String> version;
};

struct Retract {
    String version;
    Nullable<String> comment = null;
};

struct NpmPackage {
    String name;
    String version;
    StringMap<String> scripts = {};
    StringMap<String> dependencies = {};
    @SerializedName "devDependencies"
    StringMap<String> dev_dependencies = {};
};

// union DependencySpec {
//     Void workspace;
//     VersionSpec semverSpec;
// };

struct NpmPackageRef {
    String name;
    VersionSpec version;
};

type VersionSpec = String;

};
